<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Comandos básicos do Git | WTF</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Manual de sobrevivência do Git"><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>%e2%9c%a8</text></svg>"><meta property="og:title" content="Comandos básicos do Git"><meta property="og:description" content="Manual de sobrevivência do Git"><meta property="og:type" content="article"><meta property="og:url" content="https://wtf.neni.dev/comandos-basicos-git/"><meta property="article:section" content><meta property="article:published_time" content="2020-07-29T10:32:31-03:00"><meta property="article:modified_time" content="2020-07-29T10:32:31-03:00"><meta itemprop=name content="Comandos básicos do Git"><meta itemprop=description content="Manual de sobrevivência do Git"><meta itemprop=datePublished content="2020-07-29T10:32:31-03:00"><meta itemprop=dateModified content="2020-07-29T10:32:31-03:00"><meta itemprop=wordCount content="1132"><meta itemprop=keywords content="git,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Comandos básicos do Git"><meta name=twitter:description content="Manual de sobrevivência do Git"><link rel=stylesheet href=/sass/main.min.c44f64e907510667317656285b596c55db57c8d115610382304472387040b7bf.css><link rel=stylesheet href=/sass/layouts/single.min.0eb9a2da2df1ebb163bf7d2519f57722d6720f5b660d90c0b1ce3318f7aa360c.css></head><body><header class=menu><nav role=navigation><ul><li><a href=https://wtf.neni.dev>WTF</a></li><li><a href=http://neni.dev>Neni</a></li></ul></nav></header><main><article><header><time class=datepost datetime=2020-07-29T10:32:31-03:00>29/07/2020</time><div class=container-singlepost-title><h1>Comandos básicos do Git</h1><a class=fixme href=http://github.com/nenitf/wtf/edit/main/content/comandos-basicos-git.md><code>fixme</code></a></div><ul class=tags><li><a href=/tags/git>#git</a></li></ul></header><h2 id=init>init</h2><ul><li>Estrutura: <code>git init</code></li><li>Descrição: Todas mudanças realizadas versionadas com o git ficam na pasta <code>.git</code> na raiz do projeto. Para ter esse diretório - e consequentemente utilizar o git - das duas uma, ou clona um objeto (baixa um existente) com <code>git clone &lt;endereco></code> ou inicializa o git na pasta com <code>init</code></li><li>Flags:<ul><li><code>git init --bare</code> inicia servidor remote</li></ul></li></ul><hr><h2 id=clone>clone</h2><ul><li>Estrutura: <code>git clone &lt;url ou path></code></li><li>Descrição: Copia e cola projeto de acordo com a url</li><li>Flags:<ul><li><code>git clone --single-branch --branch &lt;branch> &lt;url></code> clona somente uma branch</li></ul></li><li>Observações:<ul><li><code>git clone &lt;url ou path> &lt;diretorio></code> cria projeto com nome de pasta diferente do original</li></ul></li></ul><hr><h2 id=status>status</h2><ul><li>Estrutura: <code>git status</code></li><li>Descrição: Verifica a situação dos arquivos do projeto deve-se utilizar.</li></ul><hr><h2 id=add>add</h2><ul><li>Estrutura: <code>git add &lt;file> &lt;file> ...</code><ul><li><code>&lt;file></code> é um arquivo ou diretório, caso seja usado <code>.</code> adiciona tudo do atual diretório</li></ul></li><li>Descrição: Somente arquivos <em>staged</em> podem ser <em>commitados</em>, e para isso é preciso escolher <em>untrackeds</em> ou <em>not stageds</em>. Com <code>add</code> é feita a troca de estado para <em>staged</em>.</li><li>Flags:<ul><li><code>git add -A</code> adiciona todos arquivos</li></ul></li><li>Observações:<ul><li><code>git reset &lt;file></code> troca de <em>staged</em> para <em>untracked</em> ou <em>not staged</em></li></ul></li></ul><hr><h2 id=commit>commit</h2><ul><li>Estrutura: <code>git commit</code></li><li>Descrição: O <em>commit</em> é o responsável por gravar as alterações dos arquivos stageados no projeto. É pelo histórico de <em>commits</em> que é possível retroceder até determinada versão do projeto. Os principais características que todo <em>commit</em> possui é seu <em>hash</em> (identificador), data, autor e mensagem. Com o comando é aberto um editor de texto para escrever a mensagem.</li><li>Flags:<ul><li><code>git commit -m "&lt;mensagem>"</code> cria <em>commit</em> sem abrir o editor de texto</li></ul></li><li>Observações:<ul><li>Dicas para uma mensagem de <em>commit</em>:<ul><li>Ser clara para tornar fácil o entendimento do histórico do projeto.</li><li>Possuir um título descritivo de até 50 caracteres. Se necessário especificar mais, deve-se pular uma linha e descrever parágrafos de até 70 caracteres (caso prefira listar tópicos, utilize hifens).</li><li>Utilizar verbos no imperativo sobre o que aquele <em>commit</em> afeta no código. Exemplo: ao invés de escrever &ldquo;Eu adicionei teste X&rdquo; ou &ldquo;Adicionando teste X&rdquo;, use &ldquo;Adiciona teste X&rdquo;.</li><li>Vale ressaltar que podem existir convenções para mensagens de <em>commits</em>. Uma famosa é do site <a href=http://conventionalcommits.org>conventionalcommits.org</a>, cujo foi adaptada para o framework <a href=https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md>angular</a>.</li></ul></li></ul></li></ul><hr><h2 id=remote>remote</h2><ul><li>Estrutura: <code>git remote &lt;comando></code><ul><li><code>&lt;comando></code> comandos relacionados ao <em>remote</em><ul><li><code>git remote add &lt;nome remoto> &lt;url></code> adiciona <code>&lt;nome remoto></code>, sendo normalmente <em>origin</em> ou <em>upstream</em></li></ul></li></ul></li><li>Descrição: O <a href=http://github.com>Github</a> hospeda projetos git online. Quando um projeto possui seu código salvo como no Github, ele possui um <em>remote</em>. Ao criar um projeto o git não sabe identificar aonde ele será &ldquo;guardado&rdquo;. Um projeto pode ter inúmeros <em>remotes</em> e comumente o seu principal é chamado de <em>origin</em> e o original de um fork <em>upstream</em>.</li><li>Flags:<ul><li><code>git remote -v</code> exibe nomes dos <em>remotes</em> e suas <em>urls</em></li></ul></li></ul><hr><h2 id=push>push</h2><ul><li>Estrutura: <code>git push &lt;remote> &lt;branch></code><ul><li><code>&lt;remoto></code> nome do <em>remote</em>, normalmente <em>origin</em> ou <em>upstream</em></li><li><code>&lt;branch></code> <em>branch</em> do <em>remote</em></li></ul></li><li>Descrição: Envia o código juntamente com seu histórico para o <em>remote</em>.</li></ul><hr><h2 id=log>log</h2><ul><li>Estrutura: <code>git log</code></li><li>Descrição: Lista os <em>commits</em>, podendo ser usado abaixo:</li><li>Flags:<ul><li><code>git log --pretty=oneline</code> exibe cada <em>commit</em> em uma linha</li></ul></li></ul><hr><h2 id=merge>merge</h2><ul><li>Estrutura: <code>git merge &lt;branch nova></code></li><li>Descrição: Mescla duas <em>branches</em>. Caso nenhum <em>commit</em> tenha sido criado na <em>branch</em> de origem durante os <em>commits</em> da nova <em>branch</em>, o git vai juntar todos os <em>commits</em> diretamente (sem um novo <em>commit</em> com separação e referência da <em>branch</em>). Essa situação é uma funcionalidade do git chamada <em>fast-forward</em>.</li><li>Flags:<ul><li><code>git merge &lt;branch> --no-ff</code> junta <em>branch</em> atual com <code>&lt;branch></code> sem a opção de <em>fast-forward</em></li></ul></li></ul><blockquote><p><a href=https://nvie.com/posts/a-successful-git-branching-model/#incorporating-a-finished-feature-on-develop>Prós e contras</a> de <em>fast-forward</em> pelo criador do <em>gitflow</em></p></blockquote><hr><h2 id=checkout>checkout</h2><ul><li>Estrutura: <code>git checkout &lt;referência></code><ul><li><code>&lt;referência></code> <em>branch</em>, <em>hash</em> do <em>commit</em> ou arquivo/folder precedido de <code>--</code></li></ul></li><li>Descrição:<ul><li>Troca de <em>branch</em></li><li>Acessa <em>commit</em> (transformando-o em uma branch temporária -ideal para inspecionar estado do projeto naquele ponto).</li><li>Descarta modificações de um arquivo não <em>commitado</em></li><li>se <code>&lt;referência></code> for usada como <code>git checkout &lt;remote-branch>:&lt;new-branch></code> é possível criar branch local a partir do <em>remote</em> (veja <a href=#fetch>fetch</a> para obter <em>branches</em> remotas).</li></ul></li><li>Flags:<ul><li><code>git checkout -b &lt;nova branch></code> cria <code>&lt;nova branch></code> e troca para a esta.</li><li><code>git checkout -- &lt;arquivo ou folder></code> desfaz modificações não <em>commitadas</em> do arquivo/folder. Igual ao <code>git restore &lt;arquivo ou folder></code>. Para o folder atual, tanto <code>checkout --</code> quanto <code>restore</code>, se for usado <code>.</code> é escolhido o diretório atual.</li></ul></li></ul><hr><h2 id=reset>reset</h2><ul><li>Estrutura: <code>git reset &lt;referência></code><ul><li><code>&lt;referência></code> <em>hash</em> do <em>commit</em>, a posição relativa ao HEAD (sendo um anterior <code>HEAD~1</code>, dois <code>HEAD~2</code> e etc) ou um arquivo para remover da <a href=#add>área de staged</a>.</li></ul></li><li>Descrição: Retorna o histórico ou altera a área de <em>staged</em>. Todos arquivos dos <em>commits</em> apagados permanecem (como <em>modified</em> ou <em>untracked</em>).</li><li>Flags:<ul><li><code>git reset --hard HEAD~1</code> desfaz todas alterações dos arquivos, não deixando <em>modifieds</em> ou <em>untrackeds</em></li></ul></li></ul><hr><h2 id=bisect>bisect</h2><ul><li>Estrutura: <code>git bisect &lt;comando></code><ul><li><code>&lt;comando></code> comandos relacionados ao <em>bisect</em><ul><li><code>git bisect start</code> inicia a procura pelo <em>commit</em></li><li><code>git bisect bad</code> especifica que o <em>commit</em> atual é ruim</li><li><code>git bisect good &lt;hash-commit></code> especifica o <em>commit</em> bom, para o git procurar entre as duas especificações o responsável</li><li><code>git bisect reset</code> encerra o monitoramento</li></ul></li></ul></li><li>Descrição: Encontra o <em>commit</em> que adicionaram código com bug, substitui o uso do <code>git checkout &lt;hash-commit></code> por agilizar o processo de troca de <em>commit</em>. Funciona como uma sequencia interativa de troca de comunicação entre o algoritmo do git e o comportamento que está sendo analisado. <del>é quase um quente ou frio</del></li><li>Fluxo:<ol><li><code>git bisect start</code> inicia a procura pelo <em>commit</em></li><li><code>git bisect bad</code> especifica que o <em>commit</em> atual é ruim</li><li><code>git bisect good &lt;hash-commit></code> especifica o <em>commit</em> bom, para o git procurar entre as duas especificações o responsável<ul><li>caso não saiba o <em>commit</em> bom, faça <code>git checkout &lt;hash-commit></code> até encontrá-lo, e quando achar use <code>git bisect good</code></li></ul></li><li>o git vai te trocar de <em>commit</em> a cada <code>git bisect good</code> ou <code>git bisect bad</code> até sobrar 1, portanto cabe a você monitorar</li><li>no <em>commit</em> que o git constatar ser o culpado será exibido em tela como &ldquo;o primeiro commit ruim&rdquo;</li><li><code>git bisect reset</code> para encerrar o monitoramento</li></ol><blockquote><p>com <code>git log</code> é possível saber em que <em>commit</em> está para aprovar ou não (é a HEAD)</p></blockquote></li></ul><hr><h2 id=fetch>fetch</h2><ul><li>Estrutura: <code>git fetch</code></li><li>Descrição: Atualiza as referências das <em>branches</em> dos <em>remotes</em></li><li>Observações:<ul><li><code>git fetch &lt;remote> &lt;branch></code> retorna as referências especificas de uma <em>branch</em> de um <em>remote</em><ul><li>Após trazer a referência é possível ir para essa branch com <code>git checkout &lt;branch></code></li></ul></li></ul></li></ul><h2 id=pull>pull</h2><ul><li>Estrutura: <code>git pull &lt;remoto> &lt;branch></code><ul><li><code>&lt;remoto></code> nome do <em>remote</em>, normalmente <em>origin</em> ou <em>upstream</em></li><li><code>&lt;branch></code> branch do <code>&lt;remoto></code></li></ul></li><li>Descrição: Atualiza projeto de acordo com a <em>branch</em> do <em>remoto</em>.</li></ul><hr><h2 id=stash>stash</h2><ul><li>Estrutura: <code>git stash &lt;comando></code><ul><li><code>&lt;comando></code> comandos relacionados ao <em>stash</em><ul><li><code>git stash save</code> salva modificações</li><li><code>git stash save "mensagem de descrição"</code> salva modificações com descrição</li><li><code>git stash list</code> lista <em>stashes</em></li><li><code>git stash show</code> exibe arquivos modificados do ultimo <em>stash</em></li><li><code>git stash show -p</code> exibe diffs do ultimo <em>stash</em></li><li><code>git stash clear</code> limpa área de <em>stash</em></li><li><code>git stash apply</code> aplica ultimo <em>stash</em></li><li><code>git stash pop</code> aplica ultimo <em>stash</em> e o apaga</li></ul></li><li><code>&lt;branch></code> branch do <code>&lt;remoto></code></li></ul></li><li>Descrição: Salva modificações sem commitá-las.</li></ul><hr></article></main></body></html>